# -*- coding: utf-8 -*-
"""CV | Lab2

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LX5HEWGXfiw5A3cvM7Qsf6YQDuDvZSWs

#First task
"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
from google.colab.patches import cv2_imshow

paths = [f'img{i+1}.jpg' for i in range(3)]
imgs = [cv2.imread(path, cv2.IMREAD_GRAYSCALE) for path in paths]

import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, len(imgs), figsize=(15, 5))

for ax, img in zip(axes, imgs):
    ax.imshow(img, cmap='gray')
    ax.axis('off')

plt.show()

"""#Second task"""

def get_area(img):
    mask = img > 127
    return mask.sum(), mask.mean()

def print_areas_info(imgs):
    for i, img in enumerate(imgs):
        print(f'Img{i+1}')
        print('White area (in pixels): %s \nWhite area (in percents): %.5f%%\n\n' % get_area(img))

print_areas_info(imgs)

"""#Fourth task"""

def moore_neighborhood_contour(mask):
    img = mask.copy()
    height, width = img.shape
    contour = []
    start_pixel = None

    start_pixel = np.argwhere(img == 255)
    if start_pixel.size == 0:
        return np.array(contour)
    start_pixel = tuple(start_pixel[0])
    contour.append(start_pixel)

    p = start_pixel
    current_direction = 0
    directions = np.array([
        (-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)
    ], dtype=int)

    def get_next_pixel(p, start_direction):
        for i in range(8):
            dir_index = (start_direction + i) % 8
            new_yx = np.array(p) + directions[dir_index]
            if (0 <= new_yx[0] < height and 0 <= new_yx[1] < width and img[tuple(new_yx)] == 255):
                return tuple(new_yx), dir_index
        return None, start_direction

    while True:
        c, current_direction = get_next_pixel(p, (current_direction + 6) % 8)
        if c == start_pixel:
            break
        if c:
            contour.append(c)
            img[c] = 128
            p = c

    return np.array(contour)

def calculate_contour_length(contour):
    return np.sum(np.sqrt((np.diff(contour, axis=0) ** 2).sum(axis=1)))


def opencv_contour(binary_image):
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    longest_contour = max(contours, key=cv2.contourArea)
    edge_pixels = np.array(list(map(lambda pt: tuple(pt[0]), longest_contour)))
    edge_length = calculate_contour_length(edge_pixels)
    return edge_pixels, edge_length

def process_image(image):
    mask = np.where(image > 127, 255, 0).astype(np.uint8)

    custom_contour = moore_neighborhood_contour(mask)
    custom_contour_length = calculate_contour_length(custom_contour)

    custom_contour_image = cv2.cvtColor(mask.copy(), cv2.COLOR_GRAY2BGR)
    for point in custom_contour:
        cv2.circle(custom_contour_image, (point[1], point[0]), 1, (0, 255, 0), -1)

    opencv_contour_pixels, opencv_contour_length = opencv_contour(mask.copy())

    opencv_contour_image_colored = cv2.cvtColor(mask.copy(), cv2.COLOR_GRAY2BGR)
    for pixel in opencv_contour_pixels:
        cv2.circle(opencv_contour_image_colored, (pixel[0], pixel[1]), 1, (0, 255, 0), -1)

    return custom_contour_image, custom_contour_length, opencv_contour_image_colored, opencv_contour_length

results = [process_image(image) for image in imgs]

fig, axes = plt.subplots(3, 2, figsize=(12, 18))

for i, (custom_img, custom_length, opencv_img, opencv_length) in enumerate(results):
    axes[i, 0].imshow(custom_img)
    axes[i, 0].set_title(f"Image {i+1} - Custom Contour Length: {custom_length:.2f} pixels")
    axes[i, 0].axis('off')

    axes[i, 1].imshow(opencv_img)
    axes[i, 1].set_title(f"Image {i+1} - OpenCV Contour Length: {opencv_length:.2f} pixels")
    axes[i, 1].axis('off')

plt.tight_layout()
plt.show()

"""#Sixth task"""

def distance_transform_custom(img, kernel):
    dist_transform = np.where(img == 0, 0, np.inf)
    rows, cols = img.shape

    for i in range(rows):
        for j in range(cols):
            if dist_transform[i, j] != 0:
                for (di, dj), weight in kernel:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < rows and 0 <= nj < cols:
                        dist_transform[i, j] = min(dist_transform[i, j], dist_transform[ni, nj] + weight)

    for i in range(rows - 1, -1, -1):
        for j in range(cols - 1, -1, -1):
            if dist_transform[i, j] != 0:
                for (di, dj), weight in kernel:
                    ni, nj = i + di, j + dj
                    if 0 <= ni < rows and 0 <= nj < cols:
                        dist_transform[i, j] = min(dist_transform[i, j], dist_transform[ni, nj] + weight)

    return dist_transform

manhattan_metric = [((-1, 0), 1), ((1, 0), 1), ((0, -1), 1), ((0, 1), 1)]

euclidean_metric = [
    ((-1, -1), np.sqrt(2)), ((-1, 0), 1), ((-1, 1), np.sqrt(2)),
    ((0, -1), 1),             ((0, 1), 1),
    ((1, -1), np.sqrt(2)), ((1, 0), 1), ((1, 1), np.sqrt(2))
]

chebishev_metric = [
    ((-1, -1), 1), ((-1, 0), 1), ((-1, 1), 1),
    ((0, -1), 1),               ((0, 1), 1),
    ((1, -1), 1), ((1, 0), 1), ((1, 1), 1)
]

metric_pairs = [
    (manhattan_metric, cv2.DIST_L1),
    (euclidean_metric, cv2.DIST_L2),
    (chebishev_metric, cv2.DIST_C)
    ]

for i, img in enumerate(imgs):
    for j, metric_pair in enumerate(metric_pairs):
        dist_transform = distance_transform_custom(img, metric_pair[0])

        opencv_dt = cv2.distanceTransform(img.astype(np.uint8), metric_pair[1], 0)

        plt.figure(figsize=(12, 4))
        plt.suptitle(f"Image {i+1} with Metric Pair {j+1}")

        plt.subplot(1, 3, 1)
        plt.title("Original Image")
        plt.axis('off')
        plt.imshow(img, cmap='gray')

        plt.subplot(1, 3, 2)
        plt.title("Custom Distance Transform")
        plt.axis('off')
        plt.imshow(dist_transform, cmap='hot')

        plt.subplot(1, 3, 3)
        plt.title("OpenCV Distance Transform")
        plt.axis('off')
        plt.imshow(opencv_dt, cmap='hot')

        plt.show()