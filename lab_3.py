# -*- coding: utf-8 -*-
"""lab_3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H6Afos1AmMM8dwhyH6b6cj2-CliOsQBd

#Task 0
"""

!pip install --upgrade gdown

!gdown --folder 'https://drive.google.com/drive/folders/1Q4kZBuS7btQ-3cn37QlPvzbt9jAxY970'

import os

image_folder = '/content/CV3'

image_paths = [os.path.join(image_folder, image_path) for image_path in os.listdir(image_folder)]

"""#Task 1"""

import numpy as np
import matplotlib.pyplot as plt
import cv2
import os

def binarize_image(image, threshold):
    binary_image = np.where(image > threshold, 255, 0).astype(np.uint8)
    return binary_image

def visualize_binarization_for_images(image_paths, thresholds_dict, directory):
    for full_image_path in image_paths:
        image = cv2.imread(full_image_path, cv2.IMREAD_GRAYSCALE)
        if image is None:
            print(f"Failed to load {full_image_path}")
            continue

        image_path = os.path.split(full_image_path)[1]
        thresholds = thresholds_dict.get(image_path, [])

        if not thresholds:
            print(f"No thresholds defined for {image_path}")
            continue

        num_thresholds = len(thresholds)
        fig, axes = plt.subplots(2, num_thresholds + 1, figsize=(20, 10))

        axes[0, 0].imshow(image, cmap='gray')
        axes[0, 0].set_title(f"Original: {image_path}")
        axes[0, 0].axis('off')

        axes[1, 0].axis('off')

        for i, threshold in enumerate(thresholds):

            binary_img_custom = binarize_image(image, threshold)
            axes[0, i + 1].imshow(binary_img_custom, cmap='gray')
            axes[0, i + 1].set_title(f'Custom Threshold: {threshold}')
            axes[0, i + 1].axis('off')

            _, binary_img_opencv = cv2.threshold(image, threshold, 255, cv2.THRESH_BINARY)
            axes[1, i + 1].imshow(binary_img_opencv, cmap='gray')
            axes[1, i + 1].set_title(f'OpenCV Threshold: {threshold}')
            axes[1, i + 1].axis('off')

        plt.tight_layout()
        plt.show()


thresholds_dict = {
    '1.jpg': [115, 120, 135],
    '2.jpg': [80, 90, 110],
    '3.jpg': [60, 65, 70]
}

visualize_binarization_for_images(image_paths, thresholds_dict, image_folder)

"""##Task 2"""

import cv2
import numpy as np
from google.colab.patches import cv2_imshow

def otsu_thresholding(image):
    pixel_counts = np.bincount(image.ravel(), minlength=256)
    total_pixels = image.size

    sum_all = np.dot(np.arange(256), pixel_counts)
    sum_background, weight_background, max_variance, best_threshold = 0, 0, 0, 0

    for threshold in range(256):
        weight_background += pixel_counts[threshold]
        if weight_background == 0:
            continue

        weight_foreground = total_pixels - weight_background
        if weight_foreground == 0:
            break

        sum_background += threshold * pixel_counts[threshold]
        mean_background = sum_background / weight_background
        mean_foreground = (sum_all - sum_background) / weight_foreground

        variance_between = weight_background * weight_foreground  * (mean_background - mean_foreground) ** 2

        if variance_between > max_variance:
            max_variance = variance_between
            best_threshold = threshold

    binary_image = (image > best_threshold).astype(np.uint8) * 255

    return best_threshold, binary_image

def visualize_otsu(image_paths):

    n = len(image_paths)
    fig, axes = plt.subplots(n, 3, figsize=(5*n, 15))

    for i, (image_path, ax) in enumerate(zip(image_paths, axes)):
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        ax[0].imshow(image, cmap='gray')
        ax[0].set_title('Original image')


        custom_threshold, custom_binary_image = otsu_thresholding(image)

        ax[1].imshow(custom_binary_image, cmap='gray')
        ax[1].set_title(f'Custom Otsu (threshold: {custom_threshold})')


        opencv_threshold, opencv_binary_image = cv2.threshold(image, 0, 255, cv2.THRESH_OTSU)

        ax[2].imshow(opencv_binary_image, cmap='gray')
        ax[2].set_title(f'OpenCV Otsu (threshold: {opencv_threshold})')

    for ax in axes.ravel():
        ax.axis('off')

    plt.tight_layout()
    plt.show()

visualize_otsu(image_paths)

"""#Task 3"""

import numpy as np
import cv2
from scipy.signal import convolve2d
from matplotlib import pyplot as plt

def gaussian_kernel(size, sigma):

    ax = np.linspace(-(size // 2), size // 2, size)
    x, y = np.meshgrid(ax, ax)
    kernel = np.exp(-(x**2 + y**2) / (2 * sigma**2))
    return kernel / np.sum(kernel)

def gaussian_blur(image, kernel_size=5, sigma=1.0):
    kernel = gaussian_kernel(kernel_size, sigma)

    blurred_image = convolve2d(image, kernel, mode='same', boundary='symm')
    return blurred_image.astype(np.uint8)

def normalize_image(image, epsilon=1e-8):
    return (image - image.min()) / (image.max() - image.min() + epsilon)

def winnemueller(image, sigma=0.5, alpha=3, tau=0.05, epsilon=0.5, phi=50, threshold=127):
    L_s = gaussian_blur(image, kernel_size=5, sigma=sigma)
    L_as = gaussian_blur(image, kernel_size=5, sigma=sigma * alpha)

    dog = L_s - tau * L_as

    dog_norm = normalize_image(dog)

    winnemueller_result = np.where(dog_norm > epsilon, 0, np.tanh(phi * (dog_norm - epsilon)))
    stylized_image = 255 * normalize_image(winnemueller_result)

    return (stylized_image > threshold).astype(np.uint8)


def visualize_winnemueller(image_paths, sigma=0.5, alpha=3, tau=0.05, epsilon=0.5, phi=50, threshold=127):
    n = len(image_paths)
    fig, axes = plt.subplots(n, 2, figsize=(5*n, 10))

    for i, (image_path, ax) in enumerate(zip(image_paths, axes)):
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        ax[0].imshow(image, cmap='gray')
        ax[0].set_title('Original Image')

        stylized_image = winnemueller(image, sigma=sigma, alpha=alpha, tau=tau, epsilon=epsilon, phi=phi, threshold=threshold)

        ax[1].imshow(stylized_image, cmap='gray')
        ax[1].set_title('Winnemueller Filtered')

    for ax in axes.ravel():
        ax.axis('off')

    plt.tight_layout()
    plt.show()

visualize_winnemueller(image_paths)

"""#Task 4"""

import numpy as np
import cv2
from matplotlib import pyplot as plt

def custom_region_growing(image, seed_point, threshold):
    height, width = image.shape
    segmented = np.zeros((height, width), np.uint8)
    visited = np.zeros((height, width), np.bool_)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    stack = [seed_point]
    while stack:
        cx, cy = stack.pop()
        if visited[cy, cx]:
            continue
        visited[cy, cx] = True
        segmented[cy, cx] = 255
        for dx, dy in directions:
            nx, ny = cx + dx, cy + dy
            if 0 <= nx < width and 0 <= ny < height and not visited[ny, nx]:
                if abs(int(image[ny, nx]) - int(image[cy, cx])) <= threshold:
                    stack.append((nx, ny))
    return segmented

def opencv_region_growing(image, seed_point, similarity_threshold):
    mask = np.zeros((image.shape[0] + 2, image.shape[1] + 2), dtype=np.uint8)
    seed_value = image[seed_point[1], seed_point[0]]

    lower_bound = int(seed_value - similarity_threshold)
    upper_bound = int(seed_value + similarity_threshold)

    result = image.copy()
    cv2.floodFill(result, mask, seedPoint=seed_point, newVal=255,
                  loDiff=similarity_threshold, upDiff=similarity_threshold)

    segmented = (result == 255).astype(np.uint8) * 255
    return segmented

def visualize_region_growing(image_paths, seed_point, threshold):
    n = len(image_paths)
    fig, axes = plt.subplots(n, 3, figsize=(5*n, 15))

    for i, (image_path, ax) in enumerate(zip(image_paths, axes)):
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
        ax[0].imshow(image, cmap='gray')
        ax[0].set_title('Original Image')

        custom_segmented = custom_region_growing(image, seed_point, threshold)
        ax[1].imshow(custom_segmented, cmap='gray')
        ax[1].set_title(f'Custom Region Growing')

        opencv_segmented = opencv_region_growing(image, seed_point, threshold)
        ax[2].imshow(opencv_segmented, cmap='gray')
        ax[2].set_title(f'OpenCV Region Growing')

    for ax in axes.ravel():
        ax.axis('off')

    plt.tight_layout()
    plt.show()

seed_points = (100, 150)
threshold = 10

visualize_region_growing(image_paths, seed_points, threshold)

"""#Task 5"""

import numpy as np
import cv2
import matplotlib.pyplot as plt

def mean_shift_segmentation(image, spatial_radius=5, color_radius=10, max_iter=100, epsilon=1):

    height, width = image.shape


    features = np.zeros((height, width, 3), dtype=np.float32)
    for y in range(height):
        for x in range(width):
            features[y, x] = [x, y, image[y, x]]


    flat_features = features.reshape(-1, 3)


    for i in range(flat_features.shape[0]):
        shift_point = flat_features[i]
        for _ in range(max_iter):
            spatial_dist = np.linalg.norm(flat_features[:, :2] - shift_point[:2], axis=1)
            color_dist = np.abs(flat_features[:, 2] - shift_point[2])
            in_window = (spatial_dist < spatial_radius) & (color_dist < color_radius)

            if np.sum(in_window) == 0:
                break
            mean_shift = np.mean(flat_features[in_window], axis=0)


            if np.linalg.norm(mean_shift - shift_point) < epsilon:
                break

            shift_point = mean_shift

        flat_features[i] = shift_point

    segmented_image = flat_features[:, 2].reshape(height, width)

    return segmented_image

def visualize_mean_shift(image_paths, spatial_radius=5, color_radius=10, max_iter=100, epsilon=1):
    n = len(image_paths)
    fig, axes = plt.subplots(n, 2, figsize=(10, 5 * n))

    for i, (image_path, ax) in enumerate(zip(image_paths, axes)):
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

        segmented_image = mean_shift_segmentation(image, spatial_radius, color_radius, max_iter, epsilon)

        ax[0].imshow(image, cmap='gray')
        ax[0].set_title('Original Image')
        ax[0].axis('off')

        ax[1].imshow(segmented_image, cmap='jet')
        ax[1].set_title('Mean Shift Segmented Image')
        ax[1].axis('off')

    plt.tight_layout()
    plt.show()

visualize_mean_shift(image_paths, spatial_radius=5, color_radius=10, max_iter=50, epsilon=1)

"""#Task 6"""

import numpy as np
import cv2
from scipy.ndimage import convolve
import matplotlib.pyplot as plt

def initialize_confidence(image, num_classes):
    h, w = image.shape[:2]
    confidence = np.random.rand(h, w, num_classes)
    confidence /= np.sum(confidence, axis=2, keepdims=True)
    return confidence

def compute_data_term(image, num_classes):
    h, w = image.shape[:2]
    labels = np.linspace(0, 255, num_classes)
    data_term = np.zeros((h, w, num_classes))
    for i, label in enumerate(labels):
        data_term[..., i] = (image - label) ** 2
    return -data_term

def compute_smoothness_term(confidence, beta):
    kernel = np.ones((3, 3))
    smoothness_term = np.zeros_like(confidence)
    for i in range(confidence.shape[2]):
        smoothness_term[..., i] = convolve(confidence[..., i], kernel, mode='constant')
    return -beta * smoothness_term

def confidence_propagation(image, num_classes, beta, max_iters=50, tol=1e-4):
    h, w = image.shape
    confidence = initialize_confidence(image, num_classes)
    data_term = compute_data_term(image, num_classes)

    for iteration in range(max_iters):
        smoothness_term = compute_smoothness_term(confidence, beta)
        updated_confidence = data_term + smoothness_term
        updated_confidence = np.exp(updated_confidence - np.max(updated_confidence, axis=2, keepdims=True))
        updated_confidence /= np.sum(updated_confidence, axis=2, keepdims=True)

        if np.linalg.norm(updated_confidence - confidence) < tol:
            print(f"Converged in {iteration} iterations.")
            break

        confidence = updated_confidence

    segmented_image = np.argmax(confidence, axis=2)
    return segmented_image

def visualize_confidence_propagation(image_paths, num_classes=3, beta=20, max_iters=50, tol=1e-4):
    n = len(image_paths)
    fig, axes = plt.subplots(n, 2, figsize=(10, 5 * n))

    for i, (image_path, ax) in enumerate(zip(image_paths, axes)):
        image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

        segmented_image = confidence_propagation(image, num_classes, beta, max_iters, tol)

        ax[0].imshow(image, cmap='gray')
        ax[0].set_title('Original Image')
        ax[0].axis('off')

        ax[1].imshow(segmented_image, cmap='jet')
        ax[1].set_title('Segmented Image')
        ax[1].axis('off')

    plt.tight_layout()
    plt.show()

visualize_confidence_propagation(image_paths, num_classes=10)