# -*- coding: utf-8 -*-
"""lab_5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tv7kewqzM8exz1RMuA_tvR6SfjRbV5oB

## **Лабораторна робота №5**
***Тривимірна реконтрукція***


---

## **TASK 1**
***Surface Formulation:***
"""

import numpy as np
import matplotlib.pyplot as plt

def get_surfaces(size=400):
    grid = np.mgrid[-size:size, -size:size].T.reshape(-1, 2)

    return (np.sin(grid[:, 0] / 60) * np.cos(grid[:, 1] / 60) / 8,
            (grid[:, 0]**2 + grid[:, 1]**2) / 1000000,
            np.exp(-(grid[:, 0]**2 + grid[:, 1]**2) / 32000))

wave, ball, hole = get_surfaces()

size = 400
x = np.linspace(-size, size, size * 2)
y = np.linspace(-size, size, size * 2)
X, Y = np.meshgrid(x, y)

fig = plt.figure(figsize=(18, 6))

ax1 = fig.add_subplot(131, projection='3d')
Z1 = np.sin(X / 60) * np.cos(Y / 60) / 8
ax1.plot_surface(X, Y, Z1, cmap='viridis')
ax1.set_title('Wave')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')

ax2 = fig.add_subplot(132, projection='3d')
Z2 = (X**2 + Y**2) / 1000000
ax2.plot_surface(X, Y, Z2, cmap='viridis')
ax2.set_title('Ball')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')

ax3 = fig.add_subplot(133, projection='3d')
Z3 = np.exp(-(X**2 + Y**2) / 32000)
ax3.plot_surface(X, Y, Z3, cmap='viridis')
ax3.set_title('Hole')
ax3.set_xlabel('X')
ax3.set_ylabel('Y')
ax3.set_zlabel('Z')

plt.tight_layout()
plt.show()

"""## **TASK 2**
***Depth, Distance, and Height Maps:***
"""

import numpy as np
import cv2
import matplotlib.pyplot as plt
from numpy import min, max, uint8

def norm(vals):
    return ((vals - min(vals)) / (max(vals) - min(vals)) * 255).astype(uint8)

def project_points(points_3d, K, R, t):
    points_3d = np.asarray(points_3d)
    if points_3d.ndim == 1:
        points_3d = points_3d.reshape(1, 3)

    t = np.asarray(t).reshape(3, 1)

    points_cam = R @ points_3d.T + t
    points_proj = points_cam / points_cam[2]
    points_2d = K @ points_proj

    return (points_2d[:2] / points_2d[2]).T, points_cam[2]

def compute_depth_map(surface, K, R, t, size, chosen_surface):
    points2D, depth = project_points(surface, K, R, t)
    points2D = np.floor(points2D).astype(np.int32)

    in_bounds = (
            (points2D[:, 0] >= 0) &
            (points2D[:, 0] < size * 2) &
            (points2D[:, 1] >= 0) &
            (points2D[:, 1] < size * 2))

    points2D = points2D[in_bounds]
    depth = depth[in_bounds]

    indices = np.array(range(points2D.shape[0]))
    sort_idx = np.argsort(depth)[::-1]
    sorted_indices = indices[sort_idx]
    depth = depth[sort_idx]
    depth = norm(depth)
    depth = np.abs(255 - depth)

    points2D = points2D[sorted_indices]

    depth_map = np.zeros((size * 2, size * 2), np.uint8)
    depth_map[points2D[:, 0], points2D[:, 1]] = depth

    return depth_map

def compute_distance_map(surface, K, R, t, size, chosen_surface):
    points2D, depth = project_points(surface, K, R, t)
    points2D = np.floor(points2D).astype(np.int32)

    in_bounds = (
            (points2D[:, 0] >= 0) &
            (points2D[:, 0] < size * 2) &
            (points2D[:, 1] >= 0) &
            (points2D[:, 1] < size * 2))

    points2D = points2D[in_bounds]

    indices = np.array(range(points2D.shape[0]))

    distance = surface - t.flatten()
    distance = np.sqrt(distance[:, 0] ** 2 + distance[:, 1] ** 2 + distance[:, 2] ** 2)
    distance = distance[in_bounds]

    sort_idx = np.argsort(-distance)[::-1]
    sorted_indices = indices[sort_idx]
    distance = distance[sort_idx]
    distance = norm(distance)

    points2D = points2D[sorted_indices]

    distance_map = np.zeros((size * 2, size * 2), np.uint8)
    distance_map[points2D[:, 0], points2D[:, 1]] = distance

    return distance_map

def compute_height_map(surface, size):
    height_map = norm(surface[:, 2]).reshape((size * 2, size * 2))
    return height_map

def plot_maps(hight_map, depth_map, distance_map, chosen_surface):
    fig, ax = plt.subplots(1, 3, figsize=(18, 6))

    ax[0].imshow(hight_map, cmap='viridis')
    ax[0].set_title(f"Surface Height Map {chosen_surface}")
    ax[0].axis('off')

    ax[1].imshow(depth_map, cmap='plasma')
    ax[1].set_title(f"Camera Depth Map {chosen_surface}")
    ax[1].axis('off')

    ax[2].imshow(distance_map, cmap='inferno')
    ax[2].set_title(f"Camera Distance Map {chosen_surface}")
    ax[2].axis('off')

    plt.tight_layout()
    plt.show()

def task_2(chosen_surfaces=[0]):
    size = 800

    K = np.array([
        [400, 0, size],
        [0, 400, size],
        [0, 0, 1]], dtype=np.float32)
    R = np.array([
        [1, 0, 0.5],
        [0, 1, 0],
        [-0.5, 0, 1]], dtype=np.float32)
    t = np.array([[-0.2], [0], [1.2]], dtype=np.float32)

    surface = np.zeros((size * size * 4, 3), dtype=np.float32)
    surface[:, :2] = np.mgrid[-size:size, -size:size].T.reshape(-1, 2) / size

    surf = get_surfaces(size)

    for chosen_surface in chosen_surfaces:
        surface[:, 2] = surf[chosen_surface]

        depth_map = compute_depth_map(surface, K, R, t, size, chosen_surface)
        distance_map = compute_distance_map(surface, K, R, t, size, chosen_surface)
        hight_map = compute_height_map(surface, size)

        plot_maps(hight_map, depth_map, distance_map, chosen_surface)

task_2(chosen_surfaces=[0, 1, 2])

"""## **TASK 3**
***Gradient Calculation:***
"""

import numpy as np
import matplotlib.pyplot as plt
import os

size = 400
wsize = 600

surface = np.zeros((size * size * 4, 3), dtype=np.float32)
surface[:, :2] = np.mgrid[-size:size, -size:size].T.reshape(-1, 2) / size

surf = get_surfaces(size)

for chosen_surface in range(len(surf)):
    surface[:, 2] = surf[chosen_surface]

    Z = surface[:, 2].reshape((size*2, size*2))

    gy, gx = np.gradient(Z)
    gy = norm(gy)
    gx = norm(gx)

    plt.figure(figsize=(12, 6))

    plt.subplot(1, 2, 1)
    plt.imshow(gy, cmap='viridis')
    plt.title(f'Gy (Gradient Y) for Surface {chosen_surface}')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(gx, cmap='viridis')
    plt.title(f'Gx (Gradient X) for Surface {chosen_surface}')
    plt.axis('off')

    plt.tight_layout()
    plt.show()

"""## **TASK 4**
***Two-Pass Surface Reconstruction:***
"""

import numpy as np
import matplotlib.pyplot as plt

def reconstruct_two_pass(gx, gy):
    height, width = gx.shape
    Z = np.zeros_like(gx)

    for i in range(1, height):
        Z[i, 0] = Z[i - 1, 0] + gy[i, 0]
    for j in range(1, width):
        Z[0, j] = Z[0, j - 1] + gx[0, j]

    for i in range(1, height):
        for j in range(1, width):
            Z[i, j] = (Z[i - 1, j] + Z[i, j - 1]) / 2 + (gx[i, j] + gy[i, j]) / 2

    return Z

size = 400
wsize = 600

surface = np.zeros((size * size * 4, 3), dtype=np.float32)
surface[:, :2] = np.mgrid[-size:size, -size:size].T.reshape(-1, 2) / size

surf = get_surfaces(size)

fig, axs = plt.subplots(1, len(surf), figsize=(12, 6))

for chosen_surface in range(len(surf)):
    surface[:, 2] = surf[chosen_surface]
    Z_orig = surface[:, 2].reshape((size * 2, size * 2))

    gy, gx = np.gradient(Z_orig)
    Z = reconstruct_two_pass(gx, gy)

    Z_origt = norm(Z_orig)

    axs[chosen_surface].imshow(Z, cmap='viridis')
    axs[chosen_surface].set_title(f'Reconstructed Surface {chosen_surface}')
    axs[chosen_surface].axis('off')

plt.tight_layout()
plt.show()

"""## **TASK 5**
***Frankot-Chellappa & Weyl-Klette Reconstruction:***
"""

import matplotlib.pyplot as plt
import numpy as np

def frankot_chellappa(gx, gy):
    rows, cols = gx.shape
    u, v = np.meshgrid(np.fft.fftfreq(cols), np.fft.fftfreq(rows))
    A = np.fft.fft2(gx)
    B = np.fft.fft2(gy)
    NZ = (u != 0) | (v != 0)
    Z = np.zeros_like(A, dtype=np.complex64)
    Z[NZ] = (-1j * u[NZ] * A[NZ] - 1j * v[NZ] * B[NZ]) / (u[NZ] ** 2 + v[NZ] ** 2)
    Z = np.real(np.fft.ifft2(Z))
    return Z

def wei_klette(gx, gy, L0, L1, L2, mean_depth):
    rows, cols = gx.shape
    A = np.fft.fft2(gx)
    B = np.fft.fft2(gy)
    u, v = np.meshgrid(np.fft.fftfreq(cols), np.fft.fftfreq(rows))
    H = np.zeros_like(A, dtype=np.complex64)
    NZ = (u != 0) | (v != 0)
    delta = L0 * (u ** 4 + v ** 4) + (1 + L1) * (u ** 2 + v ** 2) + L2 * (u ** 2 + v ** 2) ** 2
    H[NZ] = (-1j * (u[NZ] + L0 * u[NZ] ** 3) * A[NZ] - 1j * (v[NZ] + L0 * v[NZ] ** 3) * B[NZ]) / delta[NZ]
    H[~NZ] = mean_depth
    Z = np.real(np.fft.ifft2(H))
    return Z

def show_images(images, titles, size=6):
    fig, axes = plt.subplots(1, len(images), figsize=(size * len(images), size))
    if len(images) == 1:
        axes = [axes]
    for ax, img, title in zip(axes, images, titles):
        ax.imshow(img, cmap='viridis')
        ax.set_title(title)
        ax.axis('off')
    plt.show()

def norm(img):
    return ((img - np.min(img)) / (np.max(img) - np.min(img)) * 255).astype(np.uint8)

def get_surfaces(size=400):
    grid = np.mgrid[-size:size, -size:size].T.reshape(-1, 2)
    return (np.sin(grid[:, 0] / 60) * np.cos(grid[:, 1] / 60) / 8,
            (grid[:, 0]**2 + grid[:, 1]**2) / 1000000,
            np.exp(-(grid[:, 0]**2 + grid[:, 1]**2) / 32000))

def task_5_reconstruction():
    size = 400
    surface = np.zeros((size * size * 4, 3), dtype=np.float32)
    surface[:, :2] = np.mgrid[-size:size, -size:size].T.reshape(-1, 2) / size
    surfaces = get_surfaces(size)

    for i, surf in enumerate(surfaces):
        surface[:, 2] = surf
        Z_orig = surface[:, 2].reshape((size * 2, size * 2))

        gy, gx = np.gradient(Z_orig)

        Z_frank = frankot_chellappa(gx, gy)
        Z_wei = wei_klette(gx, gy, 0.5, 0, 0, np.mean(Z_orig))
        Z_frank = norm(Z_frank)
        Z_wei = norm(Z_wei)

        images = [Z_frank, Z_wei]
        titles = [f"Frankot Chellappa {i}", f"Wei Klette {i} (L0=0.5, L1=0, L2=0)"]

        for L0, L1, L2 in [(0.1, 0.5, 0.1), (0.5, 0.5, 0.1), (0.5, 1, 1)]:
            Z_wei = wei_klette(gx, gy, L0, L1, L2, np.mean(Z_orig))
            Z_wei = norm(Z_wei)
            images.append(Z_wei)
            titles.append(f"Wei Klette {i} (L0={L0}, L1={L1}, L2={L2})")

        show_images(images, titles, size=4)

task_5_reconstruction()

"""## **TASK 6**
***Surface Reconstruction Comparison:***
"""

from sklearn.metrics import mean_squared_error
from skimage.metrics import structural_similarity as ssim
import numpy as np
import matplotlib.pyplot as plt

def compare_reconstructions(surfaces, size):
    results = []

    for i, surface in enumerate(surfaces):
        Z_orig = surface.reshape((size * 2, size * 2))
        gy, gx = np.gradient(Z_orig)

        Z_two_pass = reconstruct_two_pass(gx, gy)
        Z_two_pass_norm = norm(Z_two_pass)

        Z_frank = frankot_chellappa(gx, gy)
        Z_frank_norm = norm(Z_frank)

        Z_wei = wei_klette(gx, gy, 0.5, 1, 1, np.mean(Z_orig))
        Z_wei_norm = norm(Z_wei)

        mse_two_pass = mean_squared_error(Z_orig.flatten(), Z_two_pass.flatten())
        mse_frank = mean_squared_error(Z_orig.flatten(), Z_frank.flatten())
        mse_wei = mean_squared_error(Z_orig.flatten(), Z_wei.flatten())

        ssim_two_pass = ssim(Z_orig, Z_two_pass, data_range=Z_two_pass.max() - Z_two_pass.min())
        ssim_frank = ssim(Z_orig, Z_frank, data_range=Z_frank.max() - Z_frank.min())
        ssim_wei = ssim(Z_orig, Z_wei, data_range=Z_wei.max() - Z_wei.min())

        results.append({
            "Surface": i,
            "MSE Two-pass": mse_two_pass,
            "MSE Frankot-Chellappa": mse_frank,
            "MSE Wei-Klette": mse_wei,
            "SSIM Two-pass": ssim_two_pass,
            "SSIM Frankot-Chellappa": ssim_frank,
            "SSIM Wei-Klette": ssim_wei
        })

        show_images(
            [norm(Z_orig), Z_two_pass_norm, Z_frank_norm, Z_wei_norm],
            [
                f"Original Surface {i}",
                f"Two-pass Reconstruction {i}",
                f"Frankot-Chellappa {i}",
                f"Wei-Klette {i} (L0=0.5, L1=1, L2=1)"
            ],
            size=4
        )

    for res in results:
        print(f"Surface {res['Surface']}:")
        print(f"  MSE Two-pass: {res['MSE Two-pass']:.4f}")
        print(f"  MSE Frankot-Chellappa: {res['MSE Frankot-Chellappa']:.4f}")
        print(f"  MSE Wei-Klette: {res['MSE Wei-Klette']:.4f}")
        print(f"  SSIM Two-pass: {res['SSIM Two-pass']:.4f}")
        print(f"  SSIM Frankot-Chellappa: {res['SSIM Frankot-Chellappa']:.4f}")
        print(f"  SSIM Wei-Klette: {res['SSIM Wei-Klette']:.4f}")
        print()

size = 400
surfaces = get_surfaces(size)
compare_reconstructions(surfaces, size)

"""## **TASK 7**
***Gradient Noise Addition:***
"""

import numpy as np
import matplotlib.pyplot as plt

def add_noise_to_gradients(gx, gy, noise_std=0.0001):

    gx_noisy = gx + np.random.normal(0, noise_std, gx.shape)
    gy_noisy = gy + np.random.normal(0, noise_std, gy.shape)

    return gx_noisy, gy_noisy

size = 400
surface = np.zeros((size * size * 4, 3), dtype=np.float32)
surface[:, :2] = np.mgrid[-size:size, -size:size].T.reshape(-1, 2) / size
surf = get_surfaces(size)

for chosen_surface in range(len(surf)):
    surface[:, 2] = surf[chosen_surface]
    Z_orig = surface[:, 2].reshape((size * 2, size * 2))

    gy, gx = np.gradient(Z_orig)

    gx_noisy, gy_noisy = add_noise_to_gradients(gx, gy)

    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.imshow(gx, cmap='viridis')
    plt.title(f'Original Gradient gx for Surface {chosen_surface}')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(gy, cmap='viridis')
    plt.title(f'Original Gradient gy for Surface {chosen_surface}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.subplot(1, 2, 1)
    plt.imshow(gx_noisy, cmap='viridis')
    plt.title(f'Noisy Gradient gx for Surface {chosen_surface}')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(gy_noisy, cmap='viridis')
    plt.title(f'Noisy Gradient gy for Surface {chosen_surface}')
    plt.axis('off')
    plt.tight_layout()
    plt.show()

"""## **TASK 8**
***Reconstruction with Noisy Gradients:***
"""

from sklearn.metrics import mean_squared_error
from skimage.metrics import structural_similarity as ssim
import numpy as np
import matplotlib.pyplot as plt

def add_noise_to_gradients(gx, gy, noise_std=0.001):
    gx_noisy = gx + np.random.normal(0, noise_std, gx.shape)
    gy_noisy = gy + np.random.normal(0, noise_std, gy.shape)
    return gx_noisy, gy_noisy

def compare_reconstructions_with_noise(surfaces, size):
    results = []

    for i, surface in enumerate(surfaces):
        Z_orig = surface.reshape((size * 2, size * 2))
        gy, gx = np.gradient(Z_orig)

        gx_noisy, gy_noisy = add_noise_to_gradients(gx, gy)

        Z_two_pass = reconstruct_two_pass(gx_noisy, gy_noisy)
        Z_two_pass_norm = norm(Z_two_pass)

        Z_frank = frankot_chellappa(gx_noisy, gy_noisy)
        Z_frank_norm = norm(Z_frank)

        Z_wei = wei_klette(gx_noisy, gy_noisy, 0.5, 1, 1, np.mean(Z_orig))
        Z_wei_norm = norm(Z_wei)

        mse_two_pass = mean_squared_error(Z_orig.flatten(), Z_two_pass.flatten())
        mse_frank = mean_squared_error(Z_orig.flatten(), Z_frank.flatten())
        mse_wei = mean_squared_error(Z_orig.flatten(), Z_wei.flatten())

        ssim_two_pass = ssim(Z_orig, Z_two_pass, data_range=Z_two_pass.max() - Z_two_pass.min())
        ssim_frank = ssim(Z_orig, Z_frank, data_range=Z_frank.max() - Z_frank.min())
        ssim_wei = ssim(Z_orig, Z_wei, data_range=Z_wei.max() - Z_wei.min())

        results.append({
            "Surface": i,
            "MSE Two-pass": mse_two_pass,
            "MSE Frankot-Chellappa": mse_frank,
            "MSE Wei-Klette": mse_wei,
            "SSIM Two-pass": ssim_two_pass,
            "SSIM Frankot-Chellappa": ssim_frank,
            "SSIM Wei-Klette": ssim_wei
        })

        show_images(
            [norm(Z_orig), Z_two_pass_norm, Z_frank_norm, Z_wei_norm],
            [
                f"Original Surface {i}",
                f"Two-pass Reconstruction {i}",
                f"Frankot-Chellappa {i}",
                f"Wei-Klette {i} (L0=0.5, L1=1, L2=1)"
            ],
            size=4
        )

    for res in results:
        print(f"Surface {res['Surface']}:")
        print(f"  MSE Two-pass: {res['MSE Two-pass']:.4f}")
        print(f"  MSE Frankot-Chellappa: {res['MSE Frankot-Chellappa']:.4f}")
        print(f"  MSE Wei-Klette: {res['MSE Wei-Klette']:.4f}")
        print(f"  SSIM Two-pass: {res['SSIM Two-pass']:.4f}")
        print(f"  SSIM Frankot-Chellappa: {res['SSIM Frankot-Chellappa']:.4f}")
        print(f"  SSIM Wei-Klette: {res['SSIM Wei-Klette']:.4f}")
        print()

size = 400
surfaces = get_surfaces(size)
compare_reconstructions_with_noise(surfaces, size)